var S=Object.defineProperty;var m=(o,t,e)=>t in o?S(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var g=(o,t,e)=>m(o,typeof t!="symbol"?t+"":t,e);class p{static async deriveKeys(t,e,r){const n=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveKey","deriveBits"]),a=new TextEncoder().encode(`${e}:${r}`),c=await crypto.subtle.deriveKey({name:"PBKDF2",salt:a,iterations:6e5,hash:"SHA-256"},n,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),s=new TextEncoder().encode(`auth:${e}:${r}`),u=await crypto.subtle.deriveBits({name:"PBKDF2",salt:s,iterations:1e5,hash:"SHA-256"},n,256),i=Array.from(new Uint8Array(u)).map(l=>l.toString(16).padStart(2,"0")).join("");return{encryptionKey:c,authHash:i}}static async encrypt(t,e){const r=typeof t=="string"?t:JSON.stringify(t),n=new TextEncoder().encode(r),a=crypto.getRandomValues(new Uint8Array(12)),c=await crypto.subtle.encrypt({name:"AES-GCM",iv:a,tagLength:128},e,n),s=Array.from(new Uint8Array(c)).map(i=>i.toString(16).padStart(2,"0")).join(""),u=Array.from(a).map(i=>i.toString(16).padStart(2,"0")).join("");return{ciphertext:s,iv:u,algorithm:"AES-256-GCM"}}static async decrypt(t,e,r=!0){const n=new Uint8Array(t.ciphertext.match(/.{2}/g).map(c=>parseInt(c,16))),a=new Uint8Array(t.iv.match(/.{2}/g).map(c=>parseInt(c,16)));try{const c=await crypto.subtle.decrypt({name:"AES-GCM",iv:a,tagLength:128},e,n),s=new TextDecoder().decode(c);if(r)try{return JSON.parse(s)}catch{return s}return s}catch{throw new Error("Decryption failed: Invalid key or corrupted data")}}static generateSalt(t=32){const e=crypto.getRandomValues(new Uint8Array(t));return Array.from(e).map(r=>r.toString(16).padStart(2,"0")).join("")}static generatePassword(t=16,e={}){const{uppercase:r=!0,lowercase:n=!0,digits:a=!0,symbols:c=!0}=e,s="ABCDEFGHIJKLMNOPQRSTUVWXYZ",u="abcdefghijklmnopqrstuvwxyz",i="0123456789",l="!@#$%^&*()_+-=[]{}|;:,.<>?";let y="";if(r&&(y+=s),n&&(y+=u),a&&(y+=i),c&&(y+=l),y.length===0)throw new Error("At least one character type must be enabled");const f=crypto.getRandomValues(new Uint32Array(t));let d="";for(let h=0;h<t;h++){const w=f[h]%y.length;d+=y[w]}return d}static calculatePasswordStrength(t){if(t.length<12||t.length>32)return 0;let e=0;return t.length>=12&&(e+=30),t.length>=16&&(e+=10),/[a-z]/.test(t)&&(e+=15),/[A-Z]/.test(t)&&(e+=15),/\d/.test(t)&&(e+=15),/[^a-zA-Z0-9]/.test(t)&&(e+=15),Math.min(e,100)}static async hash(t){const e=new TextEncoder().encode(t),r=await crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(r)).map(n=>n.toString(16).padStart(2,"0")).join("")}}class A{constructor(){g(this,"encryptionKey",null)}async initialize(t,e){const r=p.generateSalt(),{encryptionKey:n,authHash:a}=await p.deriveKeys(t,e,r);return this.encryptionKey=n,localStorage.setItem(`anynote_salt_${e}`,r),{salt:r,authHash:a}}async restore(t,e,r){const{encryptionKey:n,authHash:a}=await p.deriveKeys(t,e,r);return this.encryptionKey=n,a}getSalt(t){return localStorage.getItem(`anynote_salt_${t}`)}clear(){this.encryptionKey=null}async encrypt(t){if(!this.encryptionKey)throw new Error("加密密钥未初始化，请先登录");return p.encrypt(t,this.encryptionKey)}async decrypt(t,e=!0){if(!this.encryptionKey)throw new Error("加密密钥未初始化，请先登录");return p.decrypt(t,this.encryptionKey,e)}generatePassword(t=16,e){return p.generatePassword(t,e||{uppercase:!0,lowercase:!0,digits:!0,symbols:!0})}calculatePasswordStrength(t){return p.calculatePasswordStrength(t)}isInitialized(){return this.encryptionKey!==null}getEncryptionKey(){return this.encryptionKey}setEncryptionKey(t){this.encryptionKey=t}}const E=new A;export{E as c};
//# sourceMappingURL=crypto-DgWI3rvl.js.map
