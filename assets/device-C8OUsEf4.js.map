{"version":3,"file":"device-C8OUsEf4.js","sources":["../../../../node_modules/.pnpm/idb@8.0.3/node_modules/idb/build/index.js","../../src/lib/device-fingerprint.ts","../../src/lib/key-storage.ts","../../src/lib/device.ts"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","/**\n * è®¾å¤‡æŒ‡çº¹å·¥å…·\n * ä½¿ç”¨ FingerprintJS ç”Ÿæˆæµè§ˆå™¨å”¯ä¸€æŒ‡çº¹\n *\n * ç”¨é€”ï¼šé˜²æ­¢ IndexedDB å¯†é’¥åœ¨ä¸åŒè®¾å¤‡é—´è¢«å¤åˆ¶\n */\n\nimport FingerprintJS from '@fingerprintjs/fingerprintjs';\n\nlet fpPromise: Promise<string> | null = null;\n\n/**\n * è·å–è®¾å¤‡æŒ‡çº¹ï¼ˆç¼“å­˜ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—ï¼‰\n * @returns è®¾å¤‡æŒ‡çº¹å­—ç¬¦ä¸²ï¼ˆ64å­—ç¬¦ SHA-256 å“ˆå¸Œï¼‰\n */\nexport async function getDeviceFingerprint(): Promise<string> {\n  if (fpPromise) {\n    return fpPromise;\n  }\n\n  fpPromise = (async () => {\n    try {\n      // åŠ è½½ FingerprintJS åº“\n      const fp = await FingerprintJS.load();\n\n      // ç”ŸæˆæŒ‡çº¹\n      const result = await fp.get();\n\n      // è¿”å› visitorIdï¼ˆç¨³å®šçš„è®¾å¤‡æ ‡è¯†ï¼‰\n      return result.visitorId;\n    } catch (error) {\n      console.error('[DeviceFingerprint] ç”Ÿæˆè®¾å¤‡æŒ‡çº¹å¤±è´¥', error);\n      // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ userAgent + å±å¹•å°ºå¯¸ + è¯­è¨€ ç”Ÿæˆç®€æ˜“æŒ‡çº¹\n      const fallbackData = `${navigator.userAgent}-${screen.width}x${screen.height}-${navigator.language}`;\n      const buffer = new TextEncoder().encode(fallbackData);\n      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n    }\n  })();\n\n  return fpPromise;\n}\n\n/**\n * éªŒè¯è®¾å¤‡æŒ‡çº¹æ˜¯å¦åŒ¹é…\n * @param storedFingerprint å­˜å‚¨çš„è®¾å¤‡æŒ‡çº¹\n * @returns æ˜¯å¦åŒ¹é…\n */\nexport async function verifyDeviceFingerprint(storedFingerprint: string): Promise<boolean> {\n  const currentFingerprint = await getDeviceFingerprint();\n  return currentFingerprint === storedFingerprint;\n}\n","/**\n * IndexedDB å¯†é’¥å­˜å‚¨ç®¡ç†å™¨\n * ç”¨äºæŒä¹…åŒ–å­˜å‚¨åŠ å¯†å¯†é’¥ï¼ˆ\"è®°ä½æˆ‘7å¤©\"åŠŸèƒ½ï¼‰\n */\n\nimport { openDB, type IDBPDatabase } from 'idb';\nimport { getDeviceFingerprint, verifyDeviceFingerprint } from './device-fingerprint';\n\nconst DB_NAME = 'anynote-keys';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'keys';\n\ninterface KeyEntry {\n  deviceId: string;\n  wrappedKey: ArrayBuffer;  // åŠ å¯†å¯†é’¥è¢«åŒ…è£…å¯†é’¥åŠ å¯†åçš„ç»“æœ\n  iv: Uint8Array;           // è§£åŒ…è£…æ—¶éœ€è¦çš„ IV\n  expiresAt: number;        // è¿‡æœŸæ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰\n  fingerprint: string;      // è®¾å¤‡æŒ‡çº¹ï¼ˆé˜²æ­¢å¯†é’¥åœ¨ä¸åŒè®¾å¤‡é—´è¢«å¤åˆ¶ï¼‰\n}\n\n/**\n * æ‰“å¼€ IndexedDB æ•°æ®åº“\n */\nasync function getDB(): Promise<IDBPDatabase<any>> {\n  return openDB(DB_NAME, DB_VERSION, {\n    upgrade(db: IDBPDatabase<any>) {\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME, { keyPath: 'deviceId' });\n      }\n    },\n  });\n}\n\n/**\n * ç”ŸæˆåŒ…è£…å¯†é’¥ï¼ˆç”¨äºåŒ…è£…å®é™…çš„åŠ å¯†å¯†é’¥ï¼‰\n * åŒ…è£…å¯†é’¥å­˜å‚¨åœ¨ IndexedDB ä¸­ï¼Œextractable: false ä¿è¯å®‰å…¨æ€§\n */\nasync function generateWrappingKey(): Promise<CryptoKey> {\n  return crypto.subtle.generateKey(\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    false, // extractable: false - æ— æ³•å¯¼å‡º\n    ['wrapKey', 'unwrapKey']\n  );\n}\n\n/**\n * è·å–æˆ–åˆ›å»ºåŒ…è£…å¯†é’¥\n */\nasync function getWrappingKey(): Promise<CryptoKey> {\n  const db = await getDB();\n  const wrappingKeyData = await db.get(STORE_NAME, '__wrapping_key__');\n\n  if (wrappingKeyData && wrappingKeyData.wrappingKey) {\n    // ä» IndexedDB æ¢å¤åŒ…è£…å¯†é’¥\n    return wrappingKeyData.wrappingKey;\n  }\n\n  // ç”Ÿæˆæ–°çš„åŒ…è£…å¯†é’¥å¹¶ä¿å­˜åˆ° IndexedDB\n  const wrappingKey = await generateWrappingKey();\n  await db.put(STORE_NAME, {\n    deviceId: '__wrapping_key__',\n    wrappingKey,\n    expiresAt: 0, // åŒ…è£…å¯†é’¥ä¸è¿‡æœŸ\n  });\n\n  return wrappingKey;\n}\n\n/**\n * ä¿å­˜åŠ å¯†å¯†é’¥åˆ° IndexedDBï¼ˆä½¿ç”¨åŒ…è£…å¯†é’¥åŠ å¯†ï¼‰\n * @param deviceId è®¾å¤‡ ID\n * @param key è¦ä¿å­˜çš„åŠ å¯†å¯†é’¥\n * @param expiresAt è¿‡æœŸæ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰\n */\nexport async function saveEncryptionKey(\n  deviceId: string,\n  key: CryptoKey,\n  expiresAt: number\n): Promise<void> {\n  const db = await getDB();\n  const wrappingKey = await getWrappingKey();\n\n  // ç”Ÿæˆéšæœº IV\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n\n  // ä½¿ç”¨åŒ…è£…å¯†é’¥åŒ…è£…åŠ å¯†å¯†é’¥\n  const wrappedKey = await crypto.subtle.wrapKey(\n    'raw',\n    key,\n    wrappingKey,\n    {\n      name: 'AES-GCM',\n      iv,\n    }\n  );\n\n  // è·å–è®¾å¤‡æŒ‡çº¹\n  const fingerprint = await getDeviceFingerprint();\n\n  // ä¿å­˜åˆ° IndexedDB\n  const entry: KeyEntry = {\n    deviceId,\n    wrappedKey,\n    iv,\n    expiresAt,\n    fingerprint, // ä¿å­˜è®¾å¤‡æŒ‡çº¹\n  };\n\n  await db.put(STORE_NAME, entry);\n}\n\n/**\n * ä» IndexedDB è·å–åŠ å¯†å¯†é’¥ï¼ˆè‡ªåŠ¨æ£€æŸ¥è¿‡æœŸï¼‰\n * @param deviceId è®¾å¤‡ ID\n * @returns åŠ å¯†å¯†é’¥ï¼ˆå¦‚æœå­˜åœ¨ä¸”æœªè¿‡æœŸï¼‰ï¼Œå¦åˆ™è¿”å› null\n */\nexport async function getEncryptionKey(deviceId: string): Promise<CryptoKey | null> {\n  const db = await getDB();\n  const entry = await db.get(STORE_NAME, deviceId) as KeyEntry | undefined;\n\n  if (!entry) {\n    return null;\n  }\n\n  // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ\n  if (Date.now() > entry.expiresAt) {\n    // è¿‡æœŸï¼Œåˆ é™¤å¹¶è¿”å› null\n    await db.delete(STORE_NAME, deviceId);\n    return null;\n  }\n\n  // ğŸ” å®‰å…¨å¢å¼ºï¼šéªŒè¯è®¾å¤‡æŒ‡çº¹ï¼ˆé˜²æ­¢å¯†é’¥åœ¨ä¸åŒè®¾å¤‡é—´è¢«å¤åˆ¶ï¼‰\n  if (entry.fingerprint) {\n    const fingerprintMatches = await verifyDeviceFingerprint(entry.fingerprint);\n    if (!fingerprintMatches) {\n      console.warn('[KeyStorage] è®¾å¤‡æŒ‡çº¹éªŒè¯å¤±è´¥ï¼Œå¯†é’¥å¯èƒ½è¢«å¤åˆ¶åˆ°å…¶ä»–è®¾å¤‡');\n      // åˆ é™¤æ— æ•ˆå¯†é’¥\n      await db.delete(STORE_NAME, deviceId);\n      return null;\n    }\n  }\n\n  // è§£åŒ…è£…å¯†é’¥\n  const wrappingKey = await getWrappingKey();\n\n  try {\n    // ç¡®ä¿ IV æ˜¯æ­£ç¡®çš„ç±»å‹\n    const iv = new Uint8Array(entry.iv);\n\n    const unwrappedKey = await crypto.subtle.unwrapKey(\n      'raw',\n      entry.wrappedKey,\n      wrappingKey,\n      {\n        name: 'AES-GCM',\n        iv: iv,\n      },\n      {\n        name: 'AES-GCM',\n        length: 256,\n      },\n      false, // extractable: false - ä¿æŒå®‰å…¨æ€§\n      ['encrypt', 'decrypt']\n    );\n\n    return unwrappedKey;\n  } catch (error) {\n    console.error('è§£åŒ…è£…å¯†é’¥å¤±è´¥:', error);\n    // è§£åŒ…è£…å¤±è´¥ï¼Œåˆ é™¤æŸåçš„æ¡ç›®\n    await db.delete(STORE_NAME, deviceId);\n    return null;\n  }\n}\n\n/**\n * æ¸…é™¤æŒ‡å®šè®¾å¤‡çš„åŠ å¯†å¯†é’¥\n * @param deviceId è®¾å¤‡ ID\n */\nexport async function clearEncryptionKey(deviceId: string): Promise<void> {\n  const db = await getDB();\n  await db.delete(STORE_NAME, deviceId);\n}\n\n/**\n * æ¸…é™¤æ‰€æœ‰è®¾å¤‡çš„åŠ å¯†å¯†é’¥ï¼ˆç™»å‡ºæ—¶ä½¿ç”¨ï¼‰\n */\nexport async function clearAllKeys(): Promise<void> {\n  const db = await getDB();\n  const tx = db.transaction(STORE_NAME, 'readwrite');\n  await tx.objectStore(STORE_NAME).clear();\n  await tx.done;\n}\n\n/**\n * è·å–å¯†é’¥è¿‡æœŸæ—¶é—´\n * @param deviceId è®¾å¤‡ ID\n * @returns è¿‡æœŸæ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å› null\n */\nexport async function getKeyExpiry(deviceId: string): Promise<number | null> {\n  const db = await getDB();\n  const entry = await db.get(STORE_NAME, deviceId) as KeyEntry | undefined;\n\n  if (!entry) {\n    return null;\n  }\n\n  return entry.expiresAt;\n}\n\n/**\n * æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„æŒä¹…åŒ–å¯†é’¥\n * @param deviceId è®¾å¤‡ ID\n * @returns true å¦‚æœå­˜åœ¨ä¸”æœªè¿‡æœŸï¼Œå¦åˆ™ false\n */\nexport async function hasValidKey(deviceId: string): Promise<boolean> {\n  const db = await getDB();\n  const entry = await db.get(STORE_NAME, deviceId) as KeyEntry | undefined;\n\n  if (!entry) {\n    return false;\n  }\n\n  // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ\n  return Date.now() <= entry.expiresAt;\n}\n","/**\n * è®¾å¤‡ ID ç®¡ç†\n * ç”Ÿæˆå¹¶æŒä¹…åŒ–å®¢æˆ·ç«¯å”¯ä¸€æ ‡è¯†ç¬¦\n */\n\nconst STORAGE_KEY = 'anynote-device-id';\n\n/**\n * è·å–æˆ–åˆ›å»ºè®¾å¤‡ ID\n * @returns UUID v4 æ ¼å¼çš„è®¾å¤‡ ID\n */\nexport function getOrCreateDeviceId(): string {\n  let deviceId = localStorage.getItem(STORAGE_KEY);\n\n  if (!deviceId) {\n    deviceId = crypto.randomUUID();\n    localStorage.setItem(STORAGE_KEY, deviceId);\n  }\n\n  return deviceId;\n}\n\n/**\n * ç”Ÿæˆè®¾å¤‡æ˜¾ç¤ºåç§°\n * @returns å¦‚ \"ğŸ’» Chrome (macOS) - 10/19\" æˆ– \"ğŸ“± Safari (iOS) - 10/19\"\n */\nexport function getDeviceName(): string {\n  const ua = navigator.userAgent;\n\n  // è®¾å¤‡å›¾æ ‡\n  let icon = 'ğŸ’»';  // é»˜è®¤æ¡Œé¢ç«¯\n\n  // æµè§ˆå™¨æ£€æµ‹\n  let browser = 'Unknown Browser';\n  if (ua.includes('Edg/') || ua.includes('Edge/')) {\n    browser = 'Edge';\n  } else if (ua.includes('Chrome/') && !ua.includes('Chromium')) {\n    browser = 'Chrome';\n  } else if (ua.includes('Firefox/')) {\n    browser = 'Firefox';\n  } else if (ua.includes('Safari/') && !ua.includes('Chrome')) {\n    browser = 'Safari';\n  } else if (ua.includes('Opera/') || ua.includes('OPR/')) {\n    browser = 'Opera';\n  }\n\n  // æ“ä½œç³»ç»Ÿæ£€æµ‹ï¼ˆå«ç§»åŠ¨ç«¯ï¼‰\n  let os = 'Unknown OS';\n\n  if (ua.includes('iPhone') || ua.includes('iPad') || ua.includes('iPod')) {\n    icon = 'ğŸ“±';\n    os = 'iOS';\n    const match = ua.match(/OS (\\d+)[._]\\d+/);\n    if (match) {\n      os = `iOS ${match[1]}`;\n    }\n  } else if (ua.includes('Android')) {\n    icon = 'ğŸ“±';\n    os = 'Android';\n    const match = ua.match(/Android (\\d+(?:\\.\\d+)?)/);\n    if (match) {\n      os = `Android ${match[1]}`;\n    }\n  } else if (ua.includes('Windows')) {\n    os = 'Windows';\n    if (ua.includes('Windows NT 10.0')) {\n      os = 'Windows 10/11';\n    }\n  } else if (ua.includes('Mac OS X') || ua.includes('Macintosh')) {\n    os = 'macOS';\n  } else if (ua.includes('Linux')) {\n    os = 'Linux';\n  }\n\n  // å½“å‰æ—¥æœŸï¼ˆMM/DD æ ¼å¼ï¼‰\n  const now = new Date();\n  const month = String(now.getMonth() + 1).padStart(2, '0');\n  const day = String(now.getDate()).padStart(2, '0');\n  const date = `${month}/${day}`;\n\n  return `${icon} ${browser} (${os}) - ${date}`;\n}\n\n/**\n * æ¸…é™¤è®¾å¤‡ IDï¼ˆç”¨äºæµ‹è¯•æˆ–é‡ç½®ï¼‰\n */\nexport function clearDeviceId(): void {\n  localStorage.removeItem(STORAGE_KEY);\n}\n"],"names":["instanceOfAny","object","constructors","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","getCursorAdvanceMethods","transactionDoneMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","resolve","reject","unlisten","success","error","wrap","cacheDonePromiseForTransaction","tx","done","complete","idbProxyTraps","target","prop","receiver","value","replaceTraps","callback","wrapFunction","func","args","unwrap","transformCachableValue","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","openPromise","event","db","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","method","storeName","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","proxiedCursor","isIteratorProp","fpPromise","getDeviceFingerprint","FingerprintJS","fallbackData","buffer","hashBuffer","b","DB_NAME","DB_VERSION","STORE_NAME","getDB","generateWrappingKey","getWrappingKey","wrappingKeyData","wrappingKey","saveEncryptionKey","deviceId","key","expiresAt","iv","wrappedKey","fingerprint","entry","clearEncryptionKey","clearAllKeys","getKeyExpiry","STORAGE_KEY","getOrCreateDeviceId","getDeviceName","ua","icon","browser","os","match","now","month","day","date"],"mappings":"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","x_google_ignoreList":[0]}