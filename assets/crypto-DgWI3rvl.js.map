{"version":3,"file":"crypto-DgWI3rvl.js","sources":["../../../shared/src/crypto/crypto-engine.ts","../../src/lib/crypto.ts"],"sourcesContent":["/**\n * AnyNote 核心加密引擎\n *\n * 安全规范：\n * - 加密算法：AES-256-GCM\n * - 密钥派生：PBKDF2-SHA256（600,000 迭代）\n * - 零知识架构：主密码永不上传服务器\n *\n * 威胁模型：\n * - 防御服务器攻破：端到端加密，服务器无解密能力\n * - 防御暴力破解：高迭代 PBKDF2 + 强密码策略\n * - 防御时序攻击：常量时间比较\n *\n * @module crypto-engine\n */\n\nconst PBKDF2_ITERATIONS = 600_000; // OWASP 2025 推荐\nconst AES_KEY_LENGTH = 256;\nconst GCM_IV_LENGTH = 12; // GCM 推荐 12 字节\nconst GCM_TAG_LENGTH = 128; // 认证标签长度（位）\n\nexport interface EncryptedPayload {\n  ciphertext: string;  // Hex 编码的密文\n  iv: string;          // Hex 编码的 IV/Nonce\n  algorithm: string;   // 加密算法标识\n}\n\nexport interface DerivedKeys {\n  encryptionKey: CryptoKey;  // 用于加密数据\n  authHash: string;          // 用于服务端身份验证（Hex 编码）\n}\n\n/**\n * 核心加密引擎类\n */\nexport class CryptoEngine {\n  /**\n   * 派生主密钥和认证密钥\n   *\n   * @param masterPassword 用户主密码\n   * @param email 用户邮箱（作为盐的一部分）\n   * @param salt 随机盐（Hex 编码，注册时生成，登录时从服务器获取）\n   * @returns 派生的加密密钥和认证哈希\n   */\n  static async deriveKeys(\n    masterPassword: string,\n    email: string,\n    salt: string\n  ): Promise<DerivedKeys> {\n    // 步骤 1：将主密码转换为 CryptoKey\n    const passwordKey = await crypto.subtle.importKey(\n      'raw',\n      new TextEncoder().encode(masterPassword),\n      'PBKDF2',\n      false,\n      ['deriveKey', 'deriveBits']\n    );\n\n    // 步骤 2：结合 email 和随机盐生成唯一盐值\n    const combinedSalt = new TextEncoder().encode(`${email}:${salt}`);\n\n    // 步骤 3：派生加密密钥（用于加密数据）\n    const encryptionKey = await crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt: combinedSalt,\n        iterations: PBKDF2_ITERATIONS,\n        hash: 'SHA-256',\n      },\n      passwordKey,\n      { name: 'AES-GCM', length: AES_KEY_LENGTH },\n      true, // 可导出（允许使用 wrapKey 包装后持久化到 IndexedDB）\n      ['encrypt', 'decrypt']\n    );\n\n    // 步骤 4：派生认证密钥（用于服务端验证，较低迭代）\n    const authSalt = new TextEncoder().encode(`auth:${email}:${salt}`);\n    const authBits = await crypto.subtle.deriveBits(\n      {\n        name: 'PBKDF2',\n        salt: authSalt,\n        iterations: 100_000, // 较低迭代（仅用于认证）\n        hash: 'SHA-256',\n      },\n      passwordKey,\n      256\n    );\n\n    // 将认证密钥转换为 Hex 字符串\n    const authHash = Array.from(new Uint8Array(authBits))\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('');\n\n    return {\n      encryptionKey,\n      authHash,\n    };\n  }\n\n  /**\n   * 加密数据（AES-256-GCM）\n   *\n   * @param plaintext 明文数据（任意类型，会自动序列化）\n   * @param encryptionKey 加密密钥\n   * @returns 加密后的数据包（包含密文和 IV）\n   */\n  static async encrypt(\n    plaintext: any,\n    encryptionKey: CryptoKey\n  ): Promise<EncryptedPayload> {\n    // 步骤 1：序列化数据\n    const plaintextString = typeof plaintext === 'string'\n      ? plaintext\n      : JSON.stringify(plaintext);\n    const plaintextBuffer = new TextEncoder().encode(plaintextString);\n\n    // 步骤 2：生成随机 IV（每次加密都必须不同）\n    const iv = crypto.getRandomValues(new Uint8Array(GCM_IV_LENGTH));\n\n    // 步骤 3：使用 AES-GCM 加密\n    const ciphertextBuffer = await crypto.subtle.encrypt(\n      {\n        name: 'AES-GCM',\n        iv: iv,\n        tagLength: GCM_TAG_LENGTH,\n      },\n      encryptionKey,\n      plaintextBuffer\n    );\n\n    // 步骤 4：转换为 Hex 编码（便于存储和传输）\n    const ciphertext = Array.from(new Uint8Array(ciphertextBuffer))\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('');\n\n    const ivHex = Array.from(iv)\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('');\n\n    return {\n      ciphertext,\n      iv: ivHex,\n      algorithm: 'AES-256-GCM',\n    };\n  }\n\n  /**\n   * 解密数据（AES-256-GCM）\n   *\n   * @param payload 加密数据包\n   * @param encryptionKey 加密密钥\n   * @param parseJson 是否自动解析 JSON（默认 true）\n   * @returns 解密后的明文数据\n   */\n  static async decrypt(\n    payload: EncryptedPayload,\n    encryptionKey: CryptoKey,\n    parseJson: boolean = true\n  ): Promise<any> {\n    // 步骤 1：将 Hex 编码转换回 Uint8Array\n    const ciphertextBuffer = new Uint8Array(\n      payload.ciphertext.match(/.{2}/g)!.map((byte) => parseInt(byte, 16))\n    );\n\n    const iv = new Uint8Array(\n      payload.iv.match(/.{2}/g)!.map((byte) => parseInt(byte, 16))\n    );\n\n    // 步骤 2：使用 AES-GCM 解密\n    try {\n      const plaintextBuffer = await crypto.subtle.decrypt(\n        {\n          name: 'AES-GCM',\n          iv: iv,\n          tagLength: GCM_TAG_LENGTH,\n        },\n        encryptionKey,\n        ciphertextBuffer\n      );\n\n      // 步骤 3：转换为字符串\n      const plaintextString = new TextDecoder().decode(plaintextBuffer);\n\n      // 步骤 4：尝试解析 JSON（如果失败，返回原始字符串）\n      if (parseJson) {\n        try {\n          return JSON.parse(plaintextString);\n        } catch {\n          return plaintextString;\n        }\n      }\n\n      return plaintextString;\n    } catch (error) {\n      throw new Error('Decryption failed: Invalid key or corrupted data');\n    }\n  }\n\n  /**\n   * 生成随机盐（用于用户注册）\n   *\n   * @param length 盐的长度（字节数，默认 32）\n   * @returns Hex 编码的随机盐\n   */\n  static generateSalt(length: number = 32): string {\n    const buffer = crypto.getRandomValues(new Uint8Array(length));\n    return Array.from(buffer)\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n\n  /**\n   * 生成强随机密码（用于密码管理器）\n   *\n   * @param length 密码长度（默认 16）\n   * @param options 密码选项\n   * @returns 随机密码\n   */\n  static generatePassword(\n    length: number = 16,\n    options: {\n      uppercase?: boolean;\n      lowercase?: boolean;\n      digits?: boolean;\n      symbols?: boolean;\n    } = {}\n  ): string {\n    const {\n      uppercase = true,\n      lowercase = true,\n      digits = true,\n      symbols = true,\n    } = options;\n\n    const uppercaseChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    const lowercaseChars = 'abcdefghijklmnopqrstuvwxyz';\n    const digitChars = '0123456789';\n    const symbolChars = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n    let charset = '';\n    if (uppercase) charset += uppercaseChars;\n    if (lowercase) charset += lowercaseChars;\n    if (digits) charset += digitChars;\n    if (symbols) charset += symbolChars;\n\n    if (charset.length === 0) {\n      throw new Error('At least one character type must be enabled');\n    }\n\n    // 使用加密安全的随机数生成密码\n    const randomValues = crypto.getRandomValues(new Uint32Array(length));\n    let password = '';\n\n    for (let i = 0; i < length; i++) {\n      const randomIndex = randomValues[i] % charset.length;\n      password += charset[randomIndex];\n    }\n\n    return password;\n  }\n\n  /**\n   * 计算密码强度（0-100）\n   *\n   * @param password 待评估的密码\n   * @returns 密码强度分数（0-100）\n   */\n  static calculatePasswordStrength(password: string): number {\n    // 🔐 强制要求：最少 12 字符，最多 32 字符\n    if (password.length < 12 || password.length > 32) {\n      return 0; // 不符合长度要求，直接返回 0 分\n    }\n\n    let score = 0;\n\n    // 长度加分\n    if (password.length >= 12) score += 30; // 12字符基础分\n    if (password.length >= 16) score += 10; // 16字符额外分\n\n    // 字符类型加分\n    if (/[a-z]/.test(password)) score += 15; // 小写字母\n    if (/[A-Z]/.test(password)) score += 15; // 大写字母\n    if (/\\d/.test(password)) score += 15;    // 数字\n    if (/[^a-zA-Z0-9]/.test(password)) score += 15; // 特殊字符\n\n    return Math.min(score, 100);\n  }\n\n  /**\n   * 计算数据的 SHA-256 哈希（用于 checksum）\n   *\n   * @param data 待哈希的数据\n   * @returns Hex 编码的哈希值\n   */\n  static async hash(data: string): Promise<string> {\n    const buffer = new TextEncoder().encode(data);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n    return Array.from(new Uint8Array(hashBuffer))\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n}\n\n/**\n * 密码策略验证\n */\nexport class PasswordPolicy {\n  static readonly MIN_LENGTH = 12;\n  static readonly MIN_STRENGTH = 60;\n\n  static validate(password: string): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    if (password.length < this.MIN_LENGTH) {\n      errors.push(`密码长度至少 ${this.MIN_LENGTH} 个字符`);\n    }\n\n    if (!/[a-z]/.test(password)) {\n      errors.push('密码必须包含小写字母');\n    }\n\n    if (!/[A-Z]/.test(password)) {\n      errors.push('密码必须包含大写字母');\n    }\n\n    if (!/\\d/.test(password)) {\n      errors.push('密码必须包含数字');\n    }\n\n    if (!/[^a-zA-Z0-9]/.test(password)) {\n      errors.push('密码必须包含特殊字符');\n    }\n\n    const strength = CryptoEngine.calculatePasswordStrength(password);\n    if (strength < this.MIN_STRENGTH) {\n      errors.push(`密码强度不足（当前：${strength}/100，要求：${this.MIN_STRENGTH}/100）`);\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n}\n","/**\n * 加密引擎封装\n * 提供简化的加密/解密接口\n */\n\nimport { CryptoEngine, type EncryptedPayload } from '@anynote/shared/crypto/crypto-engine';\n\n/**\n * 加密存储管理器\n */\nexport class CryptoManager {\n  private encryptionKey: CryptoKey | null = null;\n\n  /**\n   * 初始化加密管理器（注册时）\n   */\n  async initialize(masterPassword: string, email: string): Promise<{\n    salt: string;\n    authHash: string;\n  }> {\n    // 生成随机盐\n    const salt = CryptoEngine.generateSalt();\n\n    // 派生密钥\n    const { encryptionKey, authHash } = await CryptoEngine.deriveKeys(\n      masterPassword,\n      email,\n      salt\n    );\n\n    // 保存加密密钥到内存\n    this.encryptionKey = encryptionKey;\n\n    // 保存盐值到 localStorage\n    localStorage.setItem(`anynote_salt_${email}`, salt);\n\n    return { salt, authHash };\n  }\n\n  /**\n   * 从已有盐值恢复（登录时）\n   */\n  async restore(masterPassword: string, email: string, salt: string): Promise<string> {\n    // 派生密钥\n    const { encryptionKey, authHash } = await CryptoEngine.deriveKeys(\n      masterPassword,\n      email,\n      salt\n    );\n\n    // 保存加密密钥到内存\n    this.encryptionKey = encryptionKey;\n\n    return authHash;\n  }\n\n  /**\n   * 获取盐值（从 localStorage）\n   */\n  getSalt(email: string): string | null {\n    return localStorage.getItem(`anynote_salt_${email}`);\n  }\n\n  /**\n   * 清除所有加密数据\n   */\n  clear() {\n    this.encryptionKey = null;\n  }\n\n  /**\n   * 加密数据\n   */\n  async encrypt(data: any): Promise<EncryptedPayload> {\n    if (!this.encryptionKey) {\n      throw new Error('加密密钥未初始化，请先登录');\n    }\n\n    return CryptoEngine.encrypt(data, this.encryptionKey);\n  }\n\n  /**\n   * 解密数据\n   */\n  async decrypt(payload: EncryptedPayload, parseJson = true): Promise<any> {\n    if (!this.encryptionKey) {\n      throw new Error('加密密钥未初始化，请先登录');\n    }\n\n    return CryptoEngine.decrypt(payload, this.encryptionKey, parseJson);\n  }\n\n  /**\n   * 生成随机密码\n   */\n  generatePassword(length = 16, options?: {\n    uppercase?: boolean;\n    lowercase?: boolean;\n    digits?: boolean;\n    symbols?: boolean;\n  }): string {\n    return CryptoEngine.generatePassword(length, options || {\n      uppercase: true,\n      lowercase: true,\n      digits: true,\n      symbols: true,\n    });\n  }\n\n  /**\n   * 计算密码强度\n   */\n  calculatePasswordStrength(password: string): number {\n    return CryptoEngine.calculatePasswordStrength(password);\n  }\n\n  /**\n   * 检查是否已初始化\n   */\n  isInitialized(): boolean {\n    return this.encryptionKey !== null;\n  }\n\n  /**\n   * 获取加密密钥（用于持久化存储）\n   */\n  getEncryptionKey(): CryptoKey | null {\n    return this.encryptionKey;\n  }\n\n  /**\n   * 设置加密密钥（用于从持久化存储恢复）\n   */\n  setEncryptionKey(key: CryptoKey): void {\n    this.encryptionKey = key;\n  }\n}\n\n// 全局单例\nexport const crypto = new CryptoManager();\n"],"names":["CryptoEngine","masterPassword","email","salt","passwordKey","combinedSalt","encryptionKey","authSalt","authBits","authHash","b","plaintext","plaintextString","plaintextBuffer","iv","ciphertextBuffer","ciphertext","ivHex","payload","parseJson","byte","length","buffer","options","uppercase","lowercase","digits","symbols","uppercaseChars","lowercaseChars","digitChars","symbolChars","charset","randomValues","password","i","randomIndex","score","data","hashBuffer","CryptoManager","__publicField","key","crypto"],"mappings":"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"}